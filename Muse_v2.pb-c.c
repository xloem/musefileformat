/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: Muse_v2.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "Muse_v2.pb-c.h"
void   muse_data_collection__init
                     (MuseDataCollection         *message)
{
  static MuseDataCollection init_value = MUSE_DATA_COLLECTION__INIT;
  *message = init_value;
}
size_t muse_data_collection__get_packed_size
                     (const MuseDataCollection *message)
{
  assert(message->base.descriptor == &muse_data_collection__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t muse_data_collection__pack
                     (const MuseDataCollection *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &muse_data_collection__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t muse_data_collection__pack_to_buffer
                     (const MuseDataCollection *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &muse_data_collection__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
MuseDataCollection *
       muse_data_collection__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (MuseDataCollection *)
     protobuf_c_message_unpack (&muse_data_collection__descriptor,
                                allocator, len, data);
}
void   muse_data_collection__free_unpacked
                     (MuseDataCollection *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &muse_data_collection__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   muse_data__init
                     (MuseData         *message)
{
  static MuseData init_value = MUSE_DATA__INIT;
  *message = init_value;
}
size_t muse_data__get_packed_size
                     (const MuseData *message)
{
  assert(message->base.descriptor == &muse_data__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t muse_data__pack
                     (const MuseData *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &muse_data__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t muse_data__pack_to_buffer
                     (const MuseData *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &muse_data__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
MuseData *
       muse_data__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (MuseData *)
     protobuf_c_message_unpack (&muse_data__descriptor,
                                allocator, len, data);
}
void   muse_data__free_unpacked
                     (MuseData *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &muse_data__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   eeg__init
                     (EEG         *message)
{
  static EEG init_value = EEG__INIT;
  *message = init_value;
}
size_t eeg__get_packed_size
                     (const EEG *message)
{
  assert(message->base.descriptor == &eeg__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t eeg__pack
                     (const EEG *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &eeg__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t eeg__pack_to_buffer
                     (const EEG *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &eeg__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EEG *
       eeg__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EEG *)
     protobuf_c_message_unpack (&eeg__descriptor,
                                allocator, len, data);
}
void   eeg__free_unpacked
                     (EEG *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &eeg__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   muse_quantization__init
                     (MuseQuantization         *message)
{
  static MuseQuantization init_value = MUSE_QUANTIZATION__INIT;
  *message = init_value;
}
size_t muse_quantization__get_packed_size
                     (const MuseQuantization *message)
{
  assert(message->base.descriptor == &muse_quantization__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t muse_quantization__pack
                     (const MuseQuantization *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &muse_quantization__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t muse_quantization__pack_to_buffer
                     (const MuseQuantization *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &muse_quantization__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
MuseQuantization *
       muse_quantization__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (MuseQuantization *)
     protobuf_c_message_unpack (&muse_quantization__descriptor,
                                allocator, len, data);
}
void   muse_quantization__free_unpacked
                     (MuseQuantization *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &muse_quantization__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   accelerometer__init
                     (Accelerometer         *message)
{
  static Accelerometer init_value = ACCELEROMETER__INIT;
  *message = init_value;
}
size_t accelerometer__get_packed_size
                     (const Accelerometer *message)
{
  assert(message->base.descriptor == &accelerometer__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t accelerometer__pack
                     (const Accelerometer *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &accelerometer__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t accelerometer__pack_to_buffer
                     (const Accelerometer *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &accelerometer__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Accelerometer *
       accelerometer__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Accelerometer *)
     protobuf_c_message_unpack (&accelerometer__descriptor,
                                allocator, len, data);
}
void   accelerometer__free_unpacked
                     (Accelerometer *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &accelerometer__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   annotation__init
                     (Annotation         *message)
{
  static Annotation init_value = ANNOTATION__INIT;
  *message = init_value;
}
size_t annotation__get_packed_size
                     (const Annotation *message)
{
  assert(message->base.descriptor == &annotation__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t annotation__pack
                     (const Annotation *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &annotation__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t annotation__pack_to_buffer
                     (const Annotation *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &annotation__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Annotation *
       annotation__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Annotation *)
     protobuf_c_message_unpack (&annotation__descriptor,
                                allocator, len, data);
}
void   annotation__free_unpacked
                     (Annotation *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &annotation__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   battery__init
                     (Battery         *message)
{
  static Battery init_value = BATTERY__INIT;
  *message = init_value;
}
size_t battery__get_packed_size
                     (const Battery *message)
{
  assert(message->base.descriptor == &battery__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t battery__pack
                     (const Battery *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &battery__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t battery__pack_to_buffer
                     (const Battery *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &battery__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Battery *
       battery__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Battery *)
     protobuf_c_message_unpack (&battery__descriptor,
                                allocator, len, data);
}
void   battery__free_unpacked
                     (Battery *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &battery__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   muse_version__init
                     (MuseVersion         *message)
{
  static MuseVersion init_value = MUSE_VERSION__INIT;
  *message = init_value;
}
size_t muse_version__get_packed_size
                     (const MuseVersion *message)
{
  assert(message->base.descriptor == &muse_version__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t muse_version__pack
                     (const MuseVersion *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &muse_version__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t muse_version__pack_to_buffer
                     (const MuseVersion *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &muse_version__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
MuseVersion *
       muse_version__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (MuseVersion *)
     protobuf_c_message_unpack (&muse_version__descriptor,
                                allocator, len, data);
}
void   muse_version__free_unpacked
                     (MuseVersion *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &muse_version__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   muse_config__init
                     (MuseConfig         *message)
{
  static MuseConfig init_value = MUSE_CONFIG__INIT;
  *message = init_value;
}
size_t muse_config__get_packed_size
                     (const MuseConfig *message)
{
  assert(message->base.descriptor == &muse_config__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t muse_config__pack
                     (const MuseConfig *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &muse_config__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t muse_config__pack_to_buffer
                     (const MuseConfig *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &muse_config__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
MuseConfig *
       muse_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (MuseConfig *)
     protobuf_c_message_unpack (&muse_config__descriptor,
                                allocator, len, data);
}
void   muse_config__free_unpacked
                     (MuseConfig *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &muse_config__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   eeg__dropped_samples__init
                     (EEGDroppedSamples         *message)
{
  static EEGDroppedSamples init_value = EEG__DROPPED_SAMPLES__INIT;
  *message = init_value;
}
size_t eeg__dropped_samples__get_packed_size
                     (const EEGDroppedSamples *message)
{
  assert(message->base.descriptor == &eeg__dropped_samples__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t eeg__dropped_samples__pack
                     (const EEGDroppedSamples *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &eeg__dropped_samples__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t eeg__dropped_samples__pack_to_buffer
                     (const EEGDroppedSamples *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &eeg__dropped_samples__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
EEGDroppedSamples *
       eeg__dropped_samples__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (EEGDroppedSamples *)
     protobuf_c_message_unpack (&eeg__dropped_samples__descriptor,
                                allocator, len, data);
}
void   eeg__dropped_samples__free_unpacked
                     (EEGDroppedSamples *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &eeg__dropped_samples__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   acc__dropped_samples__init
                     (ACCDroppedSamples         *message)
{
  static ACCDroppedSamples init_value = ACC__DROPPED_SAMPLES__INIT;
  *message = init_value;
}
size_t acc__dropped_samples__get_packed_size
                     (const ACCDroppedSamples *message)
{
  assert(message->base.descriptor == &acc__dropped_samples__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t acc__dropped_samples__pack
                     (const ACCDroppedSamples *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &acc__dropped_samples__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t acc__dropped_samples__pack_to_buffer
                     (const ACCDroppedSamples *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &acc__dropped_samples__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ACCDroppedSamples *
       acc__dropped_samples__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ACCDroppedSamples *)
     protobuf_c_message_unpack (&acc__dropped_samples__descriptor,
                                allocator, len, data);
}
void   acc__dropped_samples__free_unpacked
                     (ACCDroppedSamples *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &acc__dropped_samples__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   computing_device__init
                     (ComputingDevice         *message)
{
  static ComputingDevice init_value = COMPUTING_DEVICE__INIT;
  *message = init_value;
}
size_t computing_device__get_packed_size
                     (const ComputingDevice *message)
{
  assert(message->base.descriptor == &computing_device__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t computing_device__pack
                     (const ComputingDevice *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &computing_device__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t computing_device__pack_to_buffer
                     (const ComputingDevice *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &computing_device__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
ComputingDevice *
       computing_device__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (ComputingDevice *)
     protobuf_c_message_unpack (&computing_device__descriptor,
                                allocator, len, data);
}
void   computing_device__free_unpacked
                     (ComputingDevice *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &computing_device__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   dsp__init
                     (DSP         *message)
{
  static DSP init_value = DSP__INIT;
  *message = init_value;
}
size_t dsp__get_packed_size
                     (const DSP *message)
{
  assert(message->base.descriptor == &dsp__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t dsp__pack
                     (const DSP *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &dsp__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t dsp__pack_to_buffer
                     (const DSP *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &dsp__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
DSP *
       dsp__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (DSP *)
     protobuf_c_message_unpack (&dsp__descriptor,
                                allocator, len, data);
}
void   dsp__free_unpacked
                     (DSP *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &dsp__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor muse_data_collection__field_descriptors[1] =
{
  {
    "collection",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(MuseDataCollection, n_collection),
    offsetof(MuseDataCollection, collection),
    &muse_data__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned muse_data_collection__field_indices_by_name[] = {
  0,   /* field[0] = collection */
};
static const ProtobufCIntRange muse_data_collection__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor muse_data_collection__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "MuseDataCollection",
  "MuseDataCollection",
  "MuseDataCollection",
  "",
  sizeof(MuseDataCollection),
  1,
  muse_data_collection__field_descriptors,
  muse_data_collection__field_indices_by_name,
  1,  muse_data_collection__number_ranges,
  (ProtobufCMessageInit) muse_data_collection__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue muse_data__datatype__enum_values_by_number[15] =
{
  { "EEG", "MUSE_DATA__DATATYPE__EEG", 0 },
  { "QUANT", "MUSE_DATA__DATATYPE__QUANT", 1 },
  { "ACCEL", "MUSE_DATA__DATATYPE__ACCEL", 2 },
  { "BATTERY", "MUSE_DATA__DATATYPE__BATTERY", 3 },
  { "VERSION", "MUSE_DATA__DATATYPE__VERSION", 4 },
  { "CONFIG", "MUSE_DATA__DATATYPE__CONFIG", 5 },
  { "ANNOTATION", "MUSE_DATA__DATATYPE__ANNOTATION", 6 },
  { "HISTOGRAM", "MUSE_DATA__DATATYPE__HISTOGRAM", 7 },
  { "ALGVALUE", "MUSE_DATA__DATATYPE__ALGVALUE", 8 },
  { "DSP", "MUSE_DATA__DATATYPE__DSP", 9 },
  { "COMPUTING_DEVICE", "MUSE_DATA__DATATYPE__COMPUTING_DEVICE", 10 },
  { "EEG_DROPPED", "MUSE_DATA__DATATYPE__EEG_DROPPED", 11 },
  { "ACC_DROPPED", "MUSE_DATA__DATATYPE__ACC_DROPPED", 12 },
  { "CALM_APP", "MUSE_DATA__DATATYPE__CALM_APP", 13 },
  { "CALM_ALG", "MUSE_DATA__DATATYPE__CALM_ALG", 14 },
};
static const ProtobufCIntRange muse_data__datatype__value_ranges[] = {
{0, 0},{0, 15}
};
const ProtobufCEnumValueIndex muse_data__datatype__enum_values_by_name[15] =
{
  { "ACCEL", 2 },
  { "ACC_DROPPED", 12 },
  { "ALGVALUE", 8 },
  { "ANNOTATION", 6 },
  { "BATTERY", 3 },
  { "CALM_ALG", 14 },
  { "CALM_APP", 13 },
  { "COMPUTING_DEVICE", 10 },
  { "CONFIG", 5 },
  { "DSP", 9 },
  { "EEG", 0 },
  { "EEG_DROPPED", 11 },
  { "HISTOGRAM", 7 },
  { "QUANT", 1 },
  { "VERSION", 4 },
};
const ProtobufCEnumDescriptor muse_data__datatype__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "MuseData.Datatype",
  "Datatype",
  "MuseData__Datatype",
  "",
  15,
  muse_data__datatype__enum_values_by_number,
  15,
  muse_data__datatype__enum_values_by_name,
  1,
  muse_data__datatype__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const ProtobufCFieldDescriptor muse_data__field_descriptors[3] =
{
  {
    "timestamp",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_DOUBLE,
    0,   /* quantifier_offset */
    offsetof(MuseData, timestamp),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "datatype",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_ENUM,
    0,   /* quantifier_offset */
    offsetof(MuseData, datatype),
    &muse_data__datatype__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "config_id",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT64,
    offsetof(MuseData, has_config_id),
    offsetof(MuseData, config_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned muse_data__field_indices_by_name[] = {
  2,   /* field[2] = config_id */
  1,   /* field[1] = datatype */
  0,   /* field[0] = timestamp */
};
static const ProtobufCIntRange muse_data__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor muse_data__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "MuseData",
  "MuseData",
  "MuseData",
  "",
  sizeof(MuseData),
  3,
  muse_data__field_descriptors,
  muse_data__field_indices_by_name,
  1,  muse_data__number_ranges,
  (ProtobufCMessageInit) muse_data__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor eeg__field_descriptors[3] =
{
  {
    "values",
    2,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(EEG, n_values),
    offsetof(EEG, values),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "drl",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(EEG, has_drl),
    offsetof(EEG, drl),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "ref",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(EEG, has_ref),
    offsetof(EEG, ref),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned eeg__field_indices_by_name[] = {
  1,   /* field[1] = drl */
  2,   /* field[2] = ref */
  0,   /* field[0] = values */
};
static const ProtobufCIntRange eeg__number_ranges[2 + 1] =
{
  { 2, 0 },
  { 5, 1 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor eeg__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EEG",
  "EEG",
  "EEG",
  "",
  sizeof(EEG),
  3,
  eeg__field_descriptors,
  eeg__field_indices_by_name,
  2,  eeg__number_ranges,
  (ProtobufCMessageInit) eeg__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor muse_quantization__field_descriptors[1] =
{
  {
    "values",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseQuantization, n_values),
    offsetof(MuseQuantization, values),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned muse_quantization__field_indices_by_name[] = {
  0,   /* field[0] = values */
};
static const ProtobufCIntRange muse_quantization__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor muse_quantization__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "MuseQuantization",
  "MuseQuantization",
  "MuseQuantization",
  "",
  sizeof(MuseQuantization),
  1,
  muse_quantization__field_descriptors,
  muse_quantization__field_indices_by_name,
  1,  muse_quantization__number_ranges,
  (ProtobufCMessageInit) muse_quantization__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor accelerometer__field_descriptors[3] =
{
  {
    "acc1",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(Accelerometer, has_acc1),
    offsetof(Accelerometer, acc1),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "acc2",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(Accelerometer, has_acc2),
    offsetof(Accelerometer, acc2),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "acc3",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(Accelerometer, has_acc3),
    offsetof(Accelerometer, acc3),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned accelerometer__field_indices_by_name[] = {
  0,   /* field[0] = acc1 */
  1,   /* field[1] = acc2 */
  2,   /* field[2] = acc3 */
};
static const ProtobufCIntRange accelerometer__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor accelerometer__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Accelerometer",
  "Accelerometer",
  "Accelerometer",
  "",
  sizeof(Accelerometer),
  3,
  accelerometer__field_descriptors,
  accelerometer__field_indices_by_name,
  1,  accelerometer__number_ranges,
  (ProtobufCMessageInit) accelerometer__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue annotation__format__enum_values_by_number[3] =
{
  { "PLAIN_STRING", "ANNOTATION__FORMAT__PLAIN_STRING", 0 },
  { "JSON", "ANNOTATION__FORMAT__JSON", 1 },
  { "OSC", "ANNOTATION__FORMAT__OSC", 2 },
};
static const ProtobufCIntRange annotation__format__value_ranges[] = {
{0, 0},{0, 3}
};
const ProtobufCEnumValueIndex annotation__format__enum_values_by_name[3] =
{
  { "JSON", 1 },
  { "OSC", 2 },
  { "PLAIN_STRING", 0 },
};
const ProtobufCEnumDescriptor annotation__format__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "Annotation.Format",
  "Format",
  "Annotation__Format",
  "",
  3,
  annotation__format__enum_values_by_number,
  3,
  annotation__format__enum_values_by_name,
  1,
  annotation__format__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
static const Annotation__Format annotation__event_data_format__default_value = ANNOTATION__FORMAT__PLAIN_STRING;
static const ProtobufCFieldDescriptor annotation__field_descriptors[5] =
{
  {
    "event_data",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Annotation, event_data),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "event_data_format",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(Annotation, has_event_data_format),
    offsetof(Annotation, event_data_format),
    &annotation__format__descriptor,
    &annotation__event_data_format__default_value,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "event_type",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Annotation, event_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "event_id",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Annotation, event_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "parent_id",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Annotation, parent_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned annotation__field_indices_by_name[] = {
  0,   /* field[0] = event_data */
  1,   /* field[1] = event_data_format */
  3,   /* field[3] = event_id */
  2,   /* field[2] = event_type */
  4,   /* field[4] = parent_id */
};
static const ProtobufCIntRange annotation__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 5 }
};
const ProtobufCMessageDescriptor annotation__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Annotation",
  "Annotation",
  "Annotation",
  "",
  sizeof(Annotation),
  5,
  annotation__field_descriptors,
  annotation__field_indices_by_name,
  1,  annotation__number_ranges,
  (ProtobufCMessageInit) annotation__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor battery__field_descriptors[4] =
{
  {
    "percent_remaining",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Battery, has_percent_remaining),
    offsetof(Battery, percent_remaining),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "battery_fuel_gauge_millivolts",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Battery, has_battery_fuel_gauge_millivolts),
    offsetof(Battery, battery_fuel_gauge_millivolts),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "battery_adc_millivolts",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(Battery, has_battery_adc_millivolts),
    offsetof(Battery, battery_adc_millivolts),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "temperature_celsius",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(Battery, has_temperature_celsius),
    offsetof(Battery, temperature_celsius),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned battery__field_indices_by_name[] = {
  2,   /* field[2] = battery_adc_millivolts */
  1,   /* field[1] = battery_fuel_gauge_millivolts */
  0,   /* field[0] = percent_remaining */
  3,   /* field[3] = temperature_celsius */
};
static const ProtobufCIntRange battery__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor battery__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "Battery",
  "Battery",
  "Battery",
  "",
  sizeof(Battery),
  4,
  battery__field_descriptors,
  battery__field_indices_by_name,
  1,  battery__number_ranges,
  (ProtobufCMessageInit) battery__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor muse_version__field_descriptors[6] =
{
  {
    "hardware_version",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseVersion, hardware_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "firmware_headset_version",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseVersion, firmware_headset_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "firmware_type",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseVersion, firmware_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "firmware_bootloader_version",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseVersion, firmware_bootloader_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "build_number",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseVersion, build_number),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "protocol_version",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseVersion, protocol_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned muse_version__field_indices_by_name[] = {
  4,   /* field[4] = build_number */
  3,   /* field[3] = firmware_bootloader_version */
  1,   /* field[1] = firmware_headset_version */
  2,   /* field[2] = firmware_type */
  0,   /* field[0] = hardware_version */
  5,   /* field[5] = protocol_version */
};
static const ProtobufCIntRange muse_version__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 6 }
};
const ProtobufCMessageDescriptor muse_version__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "MuseVersion",
  "MuseVersion",
  "MuseVersion",
  "",
  sizeof(MuseVersion),
  6,
  muse_version__field_descriptors,
  muse_version__field_indices_by_name,
  1,  muse_version__number_ranges,
  (ProtobufCMessageInit) muse_version__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor muse_config__field_descriptors[27] =
{
  {
    "mac_addr",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseConfig, mac_addr),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "serial_number",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseConfig, serial_number),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "preset",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseConfig, preset),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "compression_enabled",
    100,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(MuseConfig, has_compression_enabled),
    offsetof(MuseConfig, compression_enabled),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "filters_enabled",
    201,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(MuseConfig, has_filters_enabled),
    offsetof(MuseConfig, filters_enabled),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "notch_frequency_hz",
    202,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_notch_frequency_hz),
    offsetof(MuseConfig, notch_frequency_hz),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_sample_frequency_hz",
    203,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_eeg_sample_frequency_hz),
    offsetof(MuseConfig, eeg_sample_frequency_hz),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_output_frequency_hz",
    204,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_eeg_output_frequency_hz),
    offsetof(MuseConfig, eeg_output_frequency_hz),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_samples_bitwidth",
    205,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_eeg_samples_bitwidth),
    offsetof(MuseConfig, eeg_samples_bitwidth),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_channel_count",
    206,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_eeg_channel_count),
    offsetof(MuseConfig, eeg_channel_count),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_channel_layout",
    207,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(MuseConfig, eeg_channel_layout),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_downsample",
    208,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_eeg_downsample),
    offsetof(MuseConfig, eeg_downsample),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_units",
    209,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(MuseConfig, has_eeg_units),
    offsetof(MuseConfig, eeg_units),
    &eegunits__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_locations",
    210,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(MuseConfig, n_eeg_locations),
    offsetof(MuseConfig, eeg_locations),
    &head_locations__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "eeg_conversion_factor",
    211,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(MuseConfig, has_eeg_conversion_factor),
    offsetof(MuseConfig, eeg_conversion_factor),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "afe_gain",
    212,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(MuseConfig, has_afe_gain),
    offsetof(MuseConfig, afe_gain),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "drlref_data_enabled",
    300,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(MuseConfig, has_drlref_data_enabled),
    offsetof(MuseConfig, drlref_data_enabled),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "drlref_conversion_factor",
    301,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(MuseConfig, has_drlref_conversion_factor),
    offsetof(MuseConfig, drlref_conversion_factor),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "drlref_sample_frequency_hz",
    302,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_drlref_sample_frequency_hz),
    offsetof(MuseConfig, drlref_sample_frequency_hz),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "acc_data_enabled",
    400,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(MuseConfig, has_acc_data_enabled),
    offsetof(MuseConfig, acc_data_enabled),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "acc_units",
    401,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_ENUM,
    offsetof(MuseConfig, has_acc_units),
    offsetof(MuseConfig, acc_units),
    &accelerometer_units__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "acc_conversion_factor",
    402,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(MuseConfig, has_acc_conversion_factor),
    offsetof(MuseConfig, acc_conversion_factor),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "acc_sample_frequency_hz",
    403,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_acc_sample_frequency_hz),
    offsetof(MuseConfig, acc_sample_frequency_hz),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "battery_data_enabled",
    500,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(MuseConfig, has_battery_data_enabled),
    offsetof(MuseConfig, battery_data_enabled),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "battery_percent_remaining",
    501,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_battery_percent_remaining),
    offsetof(MuseConfig, battery_percent_remaining),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "battery_millivolts",
    502,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(MuseConfig, has_battery_millivolts),
    offsetof(MuseConfig, battery_millivolts),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "error_data_enabled",
    600,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_BOOL,
    offsetof(MuseConfig, has_error_data_enabled),
    offsetof(MuseConfig, error_data_enabled),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned muse_config__field_indices_by_name[] = {
  21,   /* field[21] = acc_conversion_factor */
  19,   /* field[19] = acc_data_enabled */
  22,   /* field[22] = acc_sample_frequency_hz */
  20,   /* field[20] = acc_units */
  15,   /* field[15] = afe_gain */
  23,   /* field[23] = battery_data_enabled */
  25,   /* field[25] = battery_millivolts */
  24,   /* field[24] = battery_percent_remaining */
  3,   /* field[3] = compression_enabled */
  17,   /* field[17] = drlref_conversion_factor */
  16,   /* field[16] = drlref_data_enabled */
  18,   /* field[18] = drlref_sample_frequency_hz */
  9,   /* field[9] = eeg_channel_count */
  10,   /* field[10] = eeg_channel_layout */
  14,   /* field[14] = eeg_conversion_factor */
  11,   /* field[11] = eeg_downsample */
  13,   /* field[13] = eeg_locations */
  7,   /* field[7] = eeg_output_frequency_hz */
  6,   /* field[6] = eeg_sample_frequency_hz */
  8,   /* field[8] = eeg_samples_bitwidth */
  12,   /* field[12] = eeg_units */
  26,   /* field[26] = error_data_enabled */
  4,   /* field[4] = filters_enabled */
  0,   /* field[0] = mac_addr */
  5,   /* field[5] = notch_frequency_hz */
  2,   /* field[2] = preset */
  1,   /* field[1] = serial_number */
};
static const ProtobufCIntRange muse_config__number_ranges[7 + 1] =
{
  { 1, 0 },
  { 100, 3 },
  { 201, 4 },
  { 300, 16 },
  { 400, 19 },
  { 500, 23 },
  { 600, 26 },
  { 0, 27 }
};
const ProtobufCMessageDescriptor muse_config__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "MuseConfig",
  "MuseConfig",
  "MuseConfig",
  "",
  sizeof(MuseConfig),
  27,
  muse_config__field_descriptors,
  muse_config__field_indices_by_name,
  7,  muse_config__number_ranges,
  (ProtobufCMessageInit) muse_config__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor eeg__dropped_samples__field_descriptors[1] =
{
  {
    "num",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(EEGDroppedSamples, has_num),
    offsetof(EEGDroppedSamples, num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned eeg__dropped_samples__field_indices_by_name[] = {
  0,   /* field[0] = num */
};
static const ProtobufCIntRange eeg__dropped_samples__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor eeg__dropped_samples__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "EEG_DroppedSamples",
  "EEGDroppedSamples",
  "EEGDroppedSamples",
  "",
  sizeof(EEGDroppedSamples),
  1,
  eeg__dropped_samples__field_descriptors,
  eeg__dropped_samples__field_indices_by_name,
  1,  eeg__dropped_samples__number_ranges,
  (ProtobufCMessageInit) eeg__dropped_samples__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor acc__dropped_samples__field_descriptors[1] =
{
  {
    "num",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ACCDroppedSamples, has_num),
    offsetof(ACCDroppedSamples, num),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned acc__dropped_samples__field_indices_by_name[] = {
  0,   /* field[0] = num */
};
static const ProtobufCIntRange acc__dropped_samples__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor acc__dropped_samples__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ACC_DroppedSamples",
  "ACCDroppedSamples",
  "ACCDroppedSamples",
  "",
  sizeof(ACCDroppedSamples),
  1,
  acc__dropped_samples__field_descriptors,
  acc__dropped_samples__field_indices_by_name,
  1,  acc__dropped_samples__number_ranges,
  (ProtobufCMessageInit) acc__dropped_samples__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor computing_device__field_descriptors[11] =
{
  {
    "os_type",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, os_type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "os_version",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, os_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hardware_model_name",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, hardware_model_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "hardware_model_id",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, hardware_model_id),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "processor_name",
    5,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, processor_name),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "processor_speed",
    6,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, processor_speed),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "number_of_processors",
    7,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(ComputingDevice, has_number_of_processors),
    offsetof(ComputingDevice, number_of_processors),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "memory_size",
    8,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, memory_size),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "bluetooth_version",
    9,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, bluetooth_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "time_zone",
    10,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(ComputingDevice, time_zone),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "time_zone_offset_seconds",
    11,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_SINT32,
    offsetof(ComputingDevice, has_time_zone_offset_seconds),
    offsetof(ComputingDevice, time_zone_offset_seconds),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned computing_device__field_indices_by_name[] = {
  8,   /* field[8] = bluetooth_version */
  3,   /* field[3] = hardware_model_id */
  2,   /* field[2] = hardware_model_name */
  7,   /* field[7] = memory_size */
  6,   /* field[6] = number_of_processors */
  0,   /* field[0] = os_type */
  1,   /* field[1] = os_version */
  4,   /* field[4] = processor_name */
  5,   /* field[5] = processor_speed */
  9,   /* field[9] = time_zone */
  10,   /* field[10] = time_zone_offset_seconds */
};
static const ProtobufCIntRange computing_device__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 11 }
};
const ProtobufCMessageDescriptor computing_device__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "ComputingDevice",
  "ComputingDevice",
  "ComputingDevice",
  "",
  sizeof(ComputingDevice),
  11,
  computing_device__field_descriptors,
  computing_device__field_indices_by_name,
  1,  computing_device__number_ranges,
  (ProtobufCMessageInit) computing_device__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor dsp__field_descriptors[4] =
{
  {
    "type",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DSP, type),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "float_array",
    2,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_FLOAT,
    offsetof(DSP, n_float_array),
    offsetof(DSP, float_array),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "int_array",
    3,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(DSP, n_int_array),
    offsetof(DSP, int_array),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "version",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(DSP, version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned dsp__field_indices_by_name[] = {
  1,   /* field[1] = float_array */
  2,   /* field[2] = int_array */
  0,   /* field[0] = type */
  3,   /* field[3] = version */
};
static const ProtobufCIntRange dsp__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor dsp__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "DSP",
  "DSP",
  "DSP",
  "",
  sizeof(DSP),
  4,
  dsp__field_descriptors,
  dsp__field_indices_by_name,
  1,  dsp__number_ranges,
  (ProtobufCMessageInit) dsp__init,
  NULL,NULL,NULL    /* reserved[123] */
};
const ProtobufCEnumValue head_locations__enum_values_by_number[81] =
{
  { "NZ", "HEAD_LOCATIONS__NZ", 1 },
  { "FP1", "HEAD_LOCATIONS__FP1", 2 },
  { "FPZ", "HEAD_LOCATIONS__FPZ", 3 },
  { "FP2", "HEAD_LOCATIONS__FP2", 4 },
  { "AF7", "HEAD_LOCATIONS__AF7", 5 },
  { "AF3", "HEAD_LOCATIONS__AF3", 6 },
  { "AFZ", "HEAD_LOCATIONS__AFZ", 7 },
  { "AF4", "HEAD_LOCATIONS__AF4", 8 },
  { "AF8", "HEAD_LOCATIONS__AF8", 9 },
  { "F9", "HEAD_LOCATIONS__F9", 10 },
  { "F7", "HEAD_LOCATIONS__F7", 11 },
  { "F5", "HEAD_LOCATIONS__F5", 12 },
  { "F3", "HEAD_LOCATIONS__F3", 13 },
  { "F1", "HEAD_LOCATIONS__F1", 14 },
  { "FZ", "HEAD_LOCATIONS__FZ", 15 },
  { "F2", "HEAD_LOCATIONS__F2", 16 },
  { "F4", "HEAD_LOCATIONS__F4", 17 },
  { "F6", "HEAD_LOCATIONS__F6", 18 },
  { "F8", "HEAD_LOCATIONS__F8", 19 },
  { "F10", "HEAD_LOCATIONS__F10", 20 },
  { "FT9", "HEAD_LOCATIONS__FT9", 21 },
  { "FT7", "HEAD_LOCATIONS__FT7", 22 },
  { "FC5", "HEAD_LOCATIONS__FC5", 23 },
  { "FC3", "HEAD_LOCATIONS__FC3", 24 },
  { "FC1", "HEAD_LOCATIONS__FC1", 25 },
  { "FCZ", "HEAD_LOCATIONS__FCZ", 26 },
  { "FC2", "HEAD_LOCATIONS__FC2", 27 },
  { "FC4", "HEAD_LOCATIONS__FC4", 28 },
  { "FC6", "HEAD_LOCATIONS__FC6", 29 },
  { "FT8", "HEAD_LOCATIONS__FT8", 30 },
  { "FT10", "HEAD_LOCATIONS__FT10", 31 },
  { "A1", "HEAD_LOCATIONS__A1", 32 },
  { "T9", "HEAD_LOCATIONS__T9", 33 },
  { "T7", "HEAD_LOCATIONS__T7", 34 },
  { "C5", "HEAD_LOCATIONS__C5", 35 },
  { "C3", "HEAD_LOCATIONS__C3", 36 },
  { "C1", "HEAD_LOCATIONS__C1", 37 },
  { "CZ", "HEAD_LOCATIONS__CZ", 38 },
  { "C2", "HEAD_LOCATIONS__C2", 39 },
  { "C4", "HEAD_LOCATIONS__C4", 40 },
  { "C6", "HEAD_LOCATIONS__C6", 41 },
  { "T8", "HEAD_LOCATIONS__T8", 42 },
  { "T10", "HEAD_LOCATIONS__T10", 43 },
  { "A2", "HEAD_LOCATIONS__A2", 44 },
  { "TP9", "HEAD_LOCATIONS__TP9", 45 },
  { "TP7", "HEAD_LOCATIONS__TP7", 46 },
  { "CP5", "HEAD_LOCATIONS__CP5", 47 },
  { "CP3", "HEAD_LOCATIONS__CP3", 48 },
  { "CP1", "HEAD_LOCATIONS__CP1", 49 },
  { "CPZ", "HEAD_LOCATIONS__CPZ", 50 },
  { "CP2", "HEAD_LOCATIONS__CP2", 51 },
  { "CP4", "HEAD_LOCATIONS__CP4", 52 },
  { "CP6", "HEAD_LOCATIONS__CP6", 53 },
  { "TP8", "HEAD_LOCATIONS__TP8", 54 },
  { "TP10", "HEAD_LOCATIONS__TP10", 55 },
  { "P9", "HEAD_LOCATIONS__P9", 56 },
  { "P7", "HEAD_LOCATIONS__P7", 57 },
  { "P5", "HEAD_LOCATIONS__P5", 58 },
  { "P3", "HEAD_LOCATIONS__P3", 59 },
  { "P1", "HEAD_LOCATIONS__P1", 60 },
  { "PZ", "HEAD_LOCATIONS__PZ", 61 },
  { "P2", "HEAD_LOCATIONS__P2", 62 },
  { "P4", "HEAD_LOCATIONS__P4", 63 },
  { "P6", "HEAD_LOCATIONS__P6", 64 },
  { "P8", "HEAD_LOCATIONS__P8", 65 },
  { "P10", "HEAD_LOCATIONS__P10", 66 },
  { "PO7", "HEAD_LOCATIONS__PO7", 67 },
  { "PO3", "HEAD_LOCATIONS__PO3", 68 },
  { "POZ", "HEAD_LOCATIONS__POZ", 69 },
  { "PO4", "HEAD_LOCATIONS__PO4", 70 },
  { "PO8", "HEAD_LOCATIONS__PO8", 71 },
  { "O1", "HEAD_LOCATIONS__O1", 72 },
  { "OZ", "HEAD_LOCATIONS__OZ", 73 },
  { "O2", "HEAD_LOCATIONS__O2", 74 },
  { "IZ", "HEAD_LOCATIONS__IZ", 75 },
  { "AUX1", "HEAD_LOCATIONS__AUX1", 76 },
  { "AUX2", "HEAD_LOCATIONS__AUX2", 77 },
  { "AUX3", "HEAD_LOCATIONS__AUX3", 78 },
  { "AUX4", "HEAD_LOCATIONS__AUX4", 79 },
  { "MUSE_LEFT_AUX", "HEAD_LOCATIONS__MUSE_LEFT_AUX", 80 },
  { "MUSE_RIGHT_AUX", "HEAD_LOCATIONS__MUSE_RIGHT_AUX", 81 },
};
static const ProtobufCIntRange head_locations__value_ranges[] = {
{1, 0},{0, 81}
};
const ProtobufCEnumValueIndex head_locations__enum_values_by_name[81] =
{
  { "A1", 31 },
  { "A2", 43 },
  { "AF3", 5 },
  { "AF4", 7 },
  { "AF7", 4 },
  { "AF8", 8 },
  { "AFZ", 6 },
  { "AUX1", 75 },
  { "AUX2", 76 },
  { "AUX3", 77 },
  { "AUX4", 78 },
  { "C1", 36 },
  { "C2", 38 },
  { "C3", 35 },
  { "C4", 39 },
  { "C5", 34 },
  { "C6", 40 },
  { "CP1", 48 },
  { "CP2", 50 },
  { "CP3", 47 },
  { "CP4", 51 },
  { "CP5", 46 },
  { "CP6", 52 },
  { "CPZ", 49 },
  { "CZ", 37 },
  { "F1", 13 },
  { "F10", 19 },
  { "F2", 15 },
  { "F3", 12 },
  { "F4", 16 },
  { "F5", 11 },
  { "F6", 17 },
  { "F7", 10 },
  { "F8", 18 },
  { "F9", 9 },
  { "FC1", 24 },
  { "FC2", 26 },
  { "FC3", 23 },
  { "FC4", 27 },
  { "FC5", 22 },
  { "FC6", 28 },
  { "FCZ", 25 },
  { "FP1", 1 },
  { "FP2", 3 },
  { "FPZ", 2 },
  { "FT10", 30 },
  { "FT7", 21 },
  { "FT8", 29 },
  { "FT9", 20 },
  { "FZ", 14 },
  { "IZ", 74 },
  { "MUSE_LEFT_AUX", 79 },
  { "MUSE_RIGHT_AUX", 80 },
  { "NZ", 0 },
  { "O1", 71 },
  { "O2", 73 },
  { "OZ", 72 },
  { "P1", 59 },
  { "P10", 65 },
  { "P2", 61 },
  { "P3", 58 },
  { "P4", 62 },
  { "P5", 57 },
  { "P6", 63 },
  { "P7", 56 },
  { "P8", 64 },
  { "P9", 55 },
  { "PO3", 67 },
  { "PO4", 69 },
  { "PO7", 66 },
  { "PO8", 70 },
  { "POZ", 68 },
  { "PZ", 60 },
  { "T10", 42 },
  { "T7", 33 },
  { "T8", 41 },
  { "T9", 32 },
  { "TP10", 54 },
  { "TP7", 45 },
  { "TP8", 53 },
  { "TP9", 44 },
};
const ProtobufCEnumDescriptor head_locations__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "HeadLocations",
  "HeadLocations",
  "HeadLocations",
  "",
  81,
  head_locations__enum_values_by_number,
  81,
  head_locations__enum_values_by_name,
  1,
  head_locations__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue eegunits__enum_values_by_number[2] =
{
  { "EEG_MICROVOLTS", "EEGUNITS__EEG_MICROVOLTS", 1 },
  { "EEG_MUSE1_RAW", "EEGUNITS__EEG_MUSE1_RAW", 2 },
};
static const ProtobufCIntRange eegunits__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex eegunits__enum_values_by_name[2] =
{
  { "EEG_MICROVOLTS", 0 },
  { "EEG_MUSE1_RAW", 1 },
};
const ProtobufCEnumDescriptor eegunits__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "EEGUnits",
  "EEGUnits",
  "EEGUnits",
  "",
  2,
  eegunits__enum_values_by_number,
  2,
  eegunits__enum_values_by_name,
  1,
  eegunits__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
const ProtobufCEnumValue accelerometer_units__enum_values_by_number[2] =
{
  { "ACC_GFORCE", "ACCELEROMETER_UNITS__ACC_GFORCE", 1 },
  { "ACC_MUSE1_RAW", "ACCELEROMETER_UNITS__ACC_MUSE1_RAW", 2 },
};
static const ProtobufCIntRange accelerometer_units__value_ranges[] = {
{1, 0},{0, 2}
};
const ProtobufCEnumValueIndex accelerometer_units__enum_values_by_name[2] =
{
  { "ACC_GFORCE", 0 },
  { "ACC_MUSE1_RAW", 1 },
};
const ProtobufCEnumDescriptor accelerometer_units__descriptor =
{
  PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
  "AccelerometerUnits",
  "AccelerometerUnits",
  "AccelerometerUnits",
  "",
  2,
  accelerometer_units__enum_values_by_number,
  2,
  accelerometer_units__enum_values_by_name,
  1,
  accelerometer_units__value_ranges,
  NULL,NULL,NULL,NULL   /* reserved[1234] */
};
